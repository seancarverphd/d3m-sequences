\documentclass{article}
\usepackage{hyperref}
\title{Data Visualization Toward Understanding of Pipeline Diversity}
\author{Data Machines Corporation}
\begin{document}
\maketitle

We develop pipeline visualization methods with an eye of adressing
questions like the following:

\begin{enumerate}
\item 
  For a particular problem/dataset, does a particular team build
  highly diverse pipelines, with many different TA1 primitives in
  different orders? Or not?  Note: unclear if this is even “good” or
  not!
\item
  For a particular problem/dataset, are the pipelines from different
  teams substantially different (different primitives in different
  orders)?  Note: unclear if this is good or not. There might be
  convergent evolution to a good solution, or it could indicate a lack
  of diversity leaving part of the solution space unexplored.
\item
  Does a single team use many different pipelines/primitives on
  different problems of the same type? For instance, does team X
  always use primities f, then g, then h, to solve image
  classification problems? Or does their pipeline/approach vary highly
  with the particulars of the problem?  E.g. Do they treat MNIST,
  CIFAR-10, and CIFAR-100 the same?
\end{enumerate}

Our data comes from the Winter 2020 Evaluation of the D3M project.

This document consists of three parts.  The first part (these first
few pages) is the textual introduction you are now reading.  The
second part (comprising most of the document) has 103 sections, one
each visualizing the pipelines of a single problem under
consideration.  The last part (comprising the last several pages of
the document) contains a table of codes for primitives, and their
descriptions.  These codes are used throughout the second part of the
document.

Within each section, the top of the page labels the problem under
consideration.  There are two parts to each section.  The first part
of each section is an image showing, as best as possible,
``distances'' between pipelines, specifically edit distances, or
minimal number of substitutions, deletions, and insertions, needed to
transform one sequence to the other.  The second part of section shows
pipelines as coded sequences of primitives in a multiple global
alignment, including all performers and all pipelines for this problem.

To reiterate, the image was generated by first computing the edit
distances (Levenshtein distances) between all pairs of pipelines
(within and across performers) for the specific problem under
consideration.  These edit distances were then transformed and passed
to a spring layout procedure (Fruchterman-Reingold), to determine the
$x-$ and $y-$ location of the pipelines on the two-dimensional plane
of the figure.  The F-R procedure model nodes as point masses under
virtual spring forces.  Every node repels every other node, but
attractive forces exist as well that pull nodes toward each other: the
closer nodes are in edit space, the more they attract.  Described at
\url{https://networkx.github.io/documentation/stable/reference/generated/networkx.drawing.layout.spring_layout.html}{}.
Each dot in the scatter plot represents one pipeline evaluated for
that problem.  The color of the corresponding dot categorizes the 9
performers (tamu, nyu, sri, uncharted, etc).


The axes of the plot are meaningless, but pipelines with greater edit
distances between them should appear further apart on the graph.
Technically, we pass the reciprocal of the edit distance to the F-R
code, but the software does not accept infinity---and there is a
minimum distance between nodes.  As a result, identical pipelines
appear a small distance apart.  That said, it is often the case that
scatter points overlap when corresponding pipelines are identical, and
lie separated when not identical.

Note that there is some loss of information in moving the sequences to
two dimensions, as only three points can be represented equidistant in
the plane.  As a result, one can not conclude that points that are not
equidistant on the plot are not equidistant in edit space.  For
example, there can be a swarm of points in the plane for which the
pipelines differ by the substitution of a single primitive.  Nearest
neighors in this swam will tend to be equidistant, but the diameter of
the swam will be quite a bit larger than the distance to nearest
neighbors.

Let's look at an example: the first one shown below.  Here ``first''
derives from an alphbetical ordering of the problem titles, shown at
the top of each page.  This first problem has the title
``124\_174\_cifar10\_MIN\_METADATA.''  The keywords for this problem
are ``classification,'' ``multiClass,'' and ``image'' (not currently
displayed).

To me, the first thing that jumps out from the image are the patches
of yellow dots.  The table of multiple sequence alignment, second part
of each section, gives a more precise picture, of what is happening.

The alignments were creating with a program called mafft which was
originally intended for biological sequences, by minimizing an
objective function penalizing gaps and substitutions.

Colors of aligned pipelines correspond to colors of scatter points
(performers).  So the yellow pipelines, from MIT, have numbers 5435 to
5454.  But as suggested here, these only have two distict sequences.
Pipelines 5435 and 5442 have sequence SN-IB-XD-RS-EO-MM, which
according to the legend, translates to:

\begin{tabular}{rl}
SN & `Extract a DataFrame from a Dataset' \\
IB & `Determine missing semantic types for columns automatically' \\
XD & `Parses strings into their types' \\
RS & `Single Table Deep Feature Synthesis' \\
EO & `XGBoost GBTree classifier' \\
MM & `Construct pipeline predictions output'
\end{tabular}

The brown pipeline 879 (from UCB) also has this sequence.  On the
other hand, the other 17 yellow pipelines (from MIT) have sequence
SN-IB-UD-XD-ZK-ZK-UJ-MM.  The first, second, and last primitives are
the same.  The other five primitives, text starting with UD and ending with
UJ are

\begin{tabular}{rl}
  SN & \\
  IB & \\
UD & `Remove semantic types from columns' \\
XD & `Parses strings into their types' \\
ZK & `Extracts columns by semantic type' \\
ZK & `Extracts columns by semantic type' \\
UJ & `Tree-Augmented Naive Bayes Classifier' \\
MM & 
\end{tabular}
The multiple sequence alignment aligns primitives SN and IB, then
aligns the pipelines with substitutions to the end of the sequence.
Surprisingly, the common primitives MM are not aligned.  Evidently,
the algorithm prefers not to add gaps toward the end of the sequence
unless the gaps fall at the very end of the sequence.  My guess is
that gaps at the very tail of a sequence are not penalized, whereas
gaps in the middle are penalized more than substitutions.  The larger
gap penalty (larger than the substitution penalty) is applied only
when it prevents a subsequent sufficient number of substitutions.
Presumably, the large gap penalty helps prevent an undesirable number
of gaps in the alignment.


There are a few artifacts here.  A primitive denoted ** indicates a
bug (rare).

Primitive codes and their meanings are listed at the end of the document.


\end{document}
